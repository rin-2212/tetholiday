<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>T·∫øt ‚Äî C√¢y ƒë·ª©ng y√™n, ƒê√®n l·ªìng treo L√¨ x√¨ (Responsive + ch·ªëng d√≠nh)</title>
  <style>
    :root{
      --bg1:#070813;
      --gold:#ffd66b;
      --cream:#fff3d6;
    }
    html,body{height:100%; margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;}
    body{
      background: radial-gradient(1200px 700px at 50% 20%, #1b1a3a 0%, #0b1020 40%, var(--bg1) 100%);
      color:#fff;
      overflow:hidden;
      touch-action: manipulation;
    }
    canvas{ display:block; width:100vw; height:100vh; }

    .hud{
      position:fixed;
      top:12px; left:12px;
      display:flex; gap:10px; align-items:center;
      padding:10px 12px;
      background: rgba(12, 14, 26, .55);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 12px;
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      z-index: 10;
      user-select:none;
    }
    .hud .badge{
      padding:6px 10px;
      border-radius: 999px;
      background: rgba(255,214,107,.14);
      border:1px solid rgba(255,214,107,.25);
      color: var(--gold);
      font-weight: 800;
      font-size: 13px;
      letter-spacing:.2px;
      white-space: nowrap;
    }
    .hud button{
      cursor:pointer;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.08);
      color:#fff;
      padding:8px 12px;
      border-radius: 10px;
      font-weight: 800;
      transition: transform .08s ease, background .2s ease;
      white-space: nowrap;
    }
    .hud button:hover{ background: rgba(255,255,255,.12); }
    .hud button:active{ transform: translateY(1px); }

    /* Make HUD wrap nicely on small screens */
    @media (max-width: 520px){
      .hud{ right:12px; flex-wrap: wrap; }
      .hud button{ padding:8px 10px; }
    }

    .footer-note{
      position:fixed;
      bottom:12px; left:50%;
      transform: translateX(-50%);
      opacity:.85;
      font-size:12px;
      background: rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.10);
      padding:6px 10px;
      border-radius: 999px;
      backdrop-filter: blur(6px);
      user-select:none;
      z-index: 10;
      text-align:center;
      max-width: calc(100vw - 24px);
    }

    /* Popup */
    .overlay{
      position:fixed; inset:0;
      background: rgba(0,0,0,.55);
      display:none;
      align-items:center; justify-content:center;
      z-index: 50;
      backdrop-filter: blur(4px);
    }
    .modal{
      width:min(420px, calc(100vw - 28px));
      border-radius: 18px;
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      border: 1px solid rgba(255,255,255,.18);
      box-shadow: 0 18px 60px rgba(0,0,0,.55);
      padding: 16px 16px 14px;
    }
    .modal .title{
      display:flex; align-items:center; justify-content:space-between;
      gap:12px;
      margin-bottom:10px;
    }
    .modal .title h3{
      margin:0;
      font-size: 16px;
      letter-spacing:.2px;
      color: var(--cream);
    }
    .close{
      cursor:pointer;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.08);
      color:#fff;
      padding:6px 10px;
      border-radius: 10px;
      font-weight:800;
    }
    .gift{
      margin-top: 4px;
      padding: 14px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,214,107,.25);
      background: rgba(255,214,107,.10);
      color: var(--gold);
      font-weight: 950;
      font-size: 26px;
      text-align:center;
      text-shadow: 0 10px 30px rgba(0,0,0,.35);
      word-break: break-word;
    }
    .hint{
      margin-top: 10px;
      opacity:.85;
      font-size: 12px;
      line-height: 1.45;
      color: rgba(255,255,255,.9);
    }
  </style>
</head>
<body>
  <div class="hud">
    <div class="badge" id="modeBadge">C√¢y: ƒê√†o üå∏</div>
    <button id="regenBtn">Regenerate</button>
    <button id="switchBtn">ƒê·ªïi ƒê√†o / Mai</button>
  </div>

  <canvas id="c"></canvas>
  <div class="footer-note">Click v√†o phong bao l√¨ x√¨ ƒë·ªÉ m·ªü ‚Äúgi√° tr·ªã‚Äù b√™n trong ‚ú®</div>

  <div class="overlay" id="overlay">
    <div class="modal" role="dialog" aria-modal="true">
      <div class="title">
        <h3>üéÅ L√¨ x√¨ c·ªßa b·∫°n</h3>
        <button class="close" id="closeBtn">ƒê√≥ng</button>
      </div>
      <div class="gift" id="giftValue">100k</div>
      <div class="hint">M·ªói l·∫ßn b·∫•m <b>Regenerate</b> s·∫Ω random l·∫°i. M·ªánh gi√° <b>500k</b> ch·ªâ xu·∫•t hi·ªán <b>1</b> phong bao.</div>
    </div>
  </div>

  <script>
    // =========================
    // Utils
    // =========================
    const rand = (min, max) => Math.random() * (max - min) + min;
    const randi = (min, max) => Math.floor(rand(min, max + 1));
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const hypot = Math.hypot || ((x,y)=>Math.sqrt(x*x+y*y));

    function weightedPick(items){
      const total = items.reduce((s, it) => s + it[1], 0);
      let t = Math.random() * total;
      for (const [v,w] of items){
        t -= w;
        if (t <= 0) return v;
      }
      return items[items.length - 1][0];
    }

    // =========================
    // Canvas setup
    // =========================
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d', { alpha: true });

    // Offscreen layer for static tree
    const treeCanvas = document.createElement('canvas');
    const treeCtx = treeCanvas.getContext('2d', { alpha: true });

    let W=0, H=0, DPR=1;

    // polyfill roundRect
    if (!CanvasRenderingContext2D.prototype.roundRect) {
      CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
        r = typeof r === 'number' ? {tl:r,tr:r,br:r,bl:r} : r;
        this.beginPath();
        this.moveTo(x + r.tl, y);
        this.lineTo(x + w - r.tr, y);
        this.quadraticCurveTo(x + w, y, x + w, y + r.tr);
        this.lineTo(x + w, y + h - r.br);
        this.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);
        this.lineTo(x + r.bl, y + h);
        this.quadraticCurveTo(x, y + h, x, y + h - r.bl);
        this.lineTo(x, y + r.tl);
        this.quadraticCurveTo(x, y, x + r.tl, y);
        this.closePath();
        return this;
      }
    }

    // =========================
    // UI state
    // =========================
    let treeMode = "dao"; // 'dao' | 'mai'
    const modeBadge = document.getElementById('modeBadge');
    function setModeBadge(){
      modeBadge.textContent = treeMode === 'dao' ? 'C√¢y: ƒê√†o üå∏' : 'C√¢y: Mai üåº';
    }
    setModeBadge();

    // Popup
    const overlay = document.getElementById('overlay');
    const giftValue = document.getElementById('giftValue');
    const closeBtn = document.getElementById('closeBtn');
    function openPopup(value){
      giftValue.textContent = value;
      overlay.style.display = "flex";
    }
    function closePopup(){ overlay.style.display = "none"; }
    closeBtn.addEventListener('click', closePopup);
    overlay.addEventListener('click', (e)=>{ if (e.target === overlay) closePopup(); });
    addEventListener('keydown', (e)=>{ if (e.key === "Escape") closePopup(); });

    // =========================
    // Responsive scale
    // =========================
    function getUIScale(){
      const s = Math.min(W, H);
      return clamp(s / 900, 0.58, 1.00);
    }

    // =========================
    // Envelope values (500k exactly 1)
    // =========================
    function buildEnvelopeValues(count){
      const pool = [];
      const base = [
        ["Ch√∫c m·ª´ng nƒÉm m·ªõi", 7],
        ["50k", 10],
        ["100k", 7],
        ["200k", 5],
        ["300k", 3],
      ];

      // 500k only once
      pool.push("500k");

      while (pool.length < count){
        pool.push(weightedPick(base));
      }
      for (let i = pool.length - 1; i > 0; i--){
        const j = Math.floor(Math.random() * (i + 1));
        [pool[i], pool[j]] = [pool[j], pool[i]];
      }
      return pool;
    }

    // =========================
    // Scene objects
    // =========================
    const lanterns = [];

    // will be computed per populate based on screen
    let LANTERN_COUNT = 18;

    function sampleNonOverlappingPos(placed, minDist, tries = 70){
      for (let t=0; t<tries; t++){
        const x = rand(W*0.10, W*0.90);
        const y = rand(H*0.14, H*0.92);
        let ok = true;
        for (const p of placed){
          const dx = x - p.x, dy = y - p.y;
          if (dx*dx + dy*dy < minDist*minDist){ ok = false; break; }
        }
        if (ok) return {x,y};
      }
      return { x: rand(W*0.10, W*0.90), y: rand(H*0.14, H*0.92) };
    }

    function populate(){
      lanterns.length = 0;

      const ui = getUIScale();
      const shortSide = Math.min(W,H);

      // dynamic count for mobile
      LANTERN_COUNT = (shortSide < 520) ? 12 : (shortSide < 740 ? 15 : 18);

      const values = buildEnvelopeValues(LANTERN_COUNT);

      // Fixed sizes but responsive
      const r = Math.round(22 * ui);
      const envW = Math.round(60 * ui);
      const envH = Math.round(44 * ui);
      const stringLen = Math.round(50 * ui);

      // cluster radius for collision: cover lantern+envelope footprint
      // bigger -> less overlap. Tune multiplier for breathing room.
      const clusterR = Math.max((envW*0.55 + r*0.9), 36*ui);

      // minimal initial spacing to avoid immediate overlap
      const minDist = clusterR * 2.35;

      const placed = [];
      for (let i=0;i<LANTERN_COUNT;i++){
        const pos = sampleNonOverlappingPos(placed, minDist);
        placed.push(pos);

        lanterns.push({
          x: pos.x, y: pos.y,
          // velocities (slow, mobile-friendly)
          vx: rand(-0.012, 0.012) * ui,
          vy: -rand(0.020, 0.045) * ui,

          sway: rand(0, Math.PI*2),
          swaySpd: rand(0.0042, 0.0056),

          r,
          envW, envH, stringLen,
          clusterR,

          alpha: 0.92,
          glow: 0.72,
          seal: true,

          value: values[i],
          hit: null,
        });
      }
    }

    // =========================
    // Background (cheap)
    // =========================
    function drawBackground(){
      ctx.save();
      const g = ctx.createRadialGradient(W*0.5, H*0.35, 70, W*0.5, H*0.45, Math.max(W,H)*0.95);
      g.addColorStop(0, "rgba(255,255,255,0.014)");
      g.addColorStop(0.6, "rgba(0,0,0,0.10)");
      g.addColorStop(1, "rgba(0,0,0,0.62)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,W,H);
      ctx.restore();

      ctx.save();
      const gh = ctx.createLinearGradient(0, H*0.70, 0, H);
      gh.addColorStop(0, "rgba(0,0,0,0)");
      gh.addColorStop(1, "rgba(0,0,0,0.55)");
      ctx.fillStyle = gh;
      ctx.fillRect(0, H*0.70, W, H*0.30);
      ctx.restore();
    }

    // =========================
    // Lantern + envelope drawing
    // =========================
    function drawEnvelope(x, y, w, h, seal){
      ctx.save();
      const grad = ctx.createLinearGradient(x-w/2, y-h/2, x+w/2, y+h/2);
      grad.addColorStop(0, "rgba(217,35,46,0.98)");
      grad.addColorStop(1, "rgba(179,20,29,0.98)");
      ctx.fillStyle = grad;
      ctx.strokeStyle = "rgba(255,255,255,0.14)";
      ctx.lineWidth = 1;

      ctx.beginPath();
      ctx.roundRect(x - w/2, y - h/2, w, h, 10);
      ctx.fill();
      ctx.stroke();

      ctx.strokeStyle = "rgba(255,214,107,0.35)";
      ctx.lineWidth = 1.15;
      ctx.beginPath();
      ctx.moveTo(x - w/2, y - h/2);
      ctx.lineTo(x, y);
      ctx.lineTo(x + w/2, y - h/2);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(x - w/2, y + h/2);
      ctx.lineTo(x, y);
      ctx.lineTo(x + w/2, y + h/2);
      ctx.stroke();

      if (seal){
        ctx.fillStyle = "rgba(255,214,107,0.92)";
        ctx.beginPath();
        ctx.arc(x, y + h*0.12, Math.min(w,h)*0.12, 0, Math.PI*2);
        ctx.fill();

        ctx.fillStyle = "rgba(16,18,23,0.35)";
        ctx.font = `800 ${Math.max(10, Math.floor(h*0.22))}px system-ui`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("Á¶è", x, y + h*0.12 + 1);
      }
      ctx.restore();
    }

    function drawLanternWithEnvelope(o){
      ctx.save();
      ctx.globalAlpha = o.alpha;

      const swayX = Math.sin(o.sway) * (o.r * 0.34);
      const x = o.x + swayX;
      const y = o.y;

      // glow
      const glowR = o.r * 2.25 * o.glow;
      const gg = ctx.createRadialGradient(x, y, 1, x, y, glowR);
      gg.addColorStop(0, "rgba(255,214,107,0.26)");
      gg.addColorStop(1, "rgba(255,214,107,0)");
      ctx.fillStyle = gg;
      ctx.beginPath(); ctx.arc(x,y,glowR,0,Math.PI*2); ctx.fill();

      // top string
      ctx.strokeStyle = "rgba(255,255,255,0.15)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x, y - o.r*1.7);
      ctx.lineTo(x, y - o.r*1.05);
      ctx.stroke();

      // lantern body
      const bodyH = o.r * 1.55;
      const bodyW = o.r * 1.18;
      const topY = y - bodyH*0.65;
      const botY = y + bodyH*0.55;

      const rg = ctx.createLinearGradient(x - bodyW, topY, x + bodyW, botY);
      rg.addColorStop(0, "rgba(217,35,46,0.96)");
      rg.addColorStop(1, "rgba(179,20,29,0.96)");
      ctx.fillStyle = rg;
      ctx.beginPath();
      ctx.ellipse(x, y, bodyW, bodyH*0.58, 0, 0, Math.PI*2);
      ctx.fill();

      // ribs
      ctx.strokeStyle = "rgba(255,214,107,0.32)";
      ctx.lineWidth = 1.1;
      for (let i=-2;i<=2;i++){
        const t = i/3;
        ctx.beginPath();
        ctx.ellipse(x + t*bodyW*0.35, y, bodyW*(1- Math.abs(t)*0.15), bodyH*0.56, 0, 0, Math.PI*2);
        ctx.stroke();
      }

      // caps
      ctx.fillStyle = "rgba(255,214,107,0.86)";
      ctx.beginPath();
      ctx.roundRect(x - bodyW*0.58, topY - 8, bodyW*1.16, 10, 4);
      ctx.fill();

      ctx.fillStyle = "rgba(255,214,107,0.72)";
      ctx.beginPath();
      ctx.roundRect(x - bodyW*0.25, botY - 2, bodyW*0.5, 8, 4);
      ctx.fill();

      // hanging string + envelope
      const envY = botY + o.stringLen;
      ctx.strokeStyle = "rgba(255,214,107,0.44)";
      ctx.lineWidth = 1.1;
      ctx.beginPath();
      ctx.moveTo(x, botY + 6);
      ctx.lineTo(x, envY - o.envH*0.55);
      ctx.stroke();

      drawEnvelope(x, envY, o.envW, o.envH, o.seal);

      // click hitbox (axis-aligned)
      o.hit = { x: x - o.envW/2, y: envY - o.envH/2, w: o.envW, h: o.envH };

      ctx.restore();
    }

    // =========================
    // Static tree layer rendering (draw once)
    // =========================
    function renderTreeLayer(){
      treeCtx.clearRect(0,0,W,H);

      const cx = W*0.5;
      const baseY = H*0.80;

      // spotlight
      treeCtx.save();
      const halo = treeCtx.createRadialGradient(cx, baseY - H*0.23, 10, cx, baseY - H*0.23, Math.min(W,H)*0.48);
      halo.addColorStop(0, "rgba(255,214,107,0.12)");
      halo.addColorStop(0.45, "rgba(255,214,107,0.03)");
      halo.addColorStop(1, "rgba(255,214,107,0)");
      treeCtx.fillStyle = halo;
      treeCtx.beginPath(); treeCtx.arc(cx, baseY - H*0.23, Math.min(W,H)*0.48, 0, Math.PI*2); treeCtx.fill();
      treeCtx.restore();

      // trunk
      const trunkW = Math.min(76, W*0.075);
      const trunkH = Math.min(270, H*0.33);

      treeCtx.save();
      const bark = treeCtx.createLinearGradient(cx - trunkW, baseY, cx + trunkW, baseY - trunkH);
      bark.addColorStop(0, "rgba(88,50,28,0.96)");
      bark.addColorStop(1, "rgba(47,22,12,0.96)");
      treeCtx.fillStyle = bark;

      treeCtx.beginPath();
      treeCtx.moveTo(cx - trunkW*0.62, baseY);
      treeCtx.bezierCurveTo(cx - trunkW*0.95, baseY - trunkH*0.35, cx - trunkW*0.38, baseY - trunkH*0.82, cx - trunkW*0.22, baseY - trunkH);
      treeCtx.lineTo(cx + trunkW*0.25, baseY - trunkH);
      treeCtx.bezierCurveTo(cx + trunkW*0.45, baseY - trunkH*0.80, cx + trunkW*1.02, baseY - trunkH*0.35, cx + trunkW*0.70, baseY);
      treeCtx.closePath();
      treeCtx.fill();

      treeCtx.fillStyle = "rgba(0,0,0,0.28)";
      treeCtx.beginPath();
      treeCtx.ellipse(cx, baseY+10, trunkW*1.8, 18, 0, 0, Math.PI*2);
      treeCtx.fill();
      treeCtx.restore();

      // blossoms (static)
      const canopyCenterY = baseY - trunkH*0.92;

      function blossomColor(depth){
        if (treeMode === "dao"){
          const a = 0.40 + depth*0.45;
          return {
            glow: `rgba(255,119,168,${0.10 + depth*0.12})`,
            petal1: `rgba(255,119,168,${a})`,
            petal2: `rgba(255,183,214,${a})`,
            core: `rgba(255,243,214,${0.55 + depth*0.35})`,
          };
        }
        const a = 0.40 + depth*0.45;
        return {
          glow: `rgba(255,214,107,${0.10 + depth*0.10})`,
          petal1: `rgba(255,214,107,${a})`,
          petal2: `rgba(255,242,190,${a})`,
          core: `rgba(255,243,214,${0.55 + depth*0.35})`,
        };
      }

      function drawBlossom(x,y, r, depth){
        const c = blossomColor(depth);
        treeCtx.save();

        const gg = treeCtx.createRadialGradient(x,y,1,x,y,r*3.0);
        gg.addColorStop(0, c.glow);
        gg.addColorStop(1, "rgba(0,0,0,0)");
        treeCtx.fillStyle = gg;
        treeCtx.beginPath(); treeCtx.arc(x,y,r*3.0,0,Math.PI*2); treeCtx.fill();

        for (let i=0;i<5;i++){
          const a = (Math.PI*2)*i/5 + rand(-0.10,0.10);
          const px = x + Math.cos(a)*r*0.65;
          const py = y + Math.sin(a)*r*0.65;

          const pg = treeCtx.createRadialGradient(px,py,1,px,py,r*1.25);
          pg.addColorStop(0, c.petal2);
          pg.addColorStop(1, c.petal1);
          treeCtx.fillStyle = pg;

          treeCtx.beginPath();
          treeCtx.ellipse(px, py, r*1.05, r*0.62, a, 0, Math.PI*2);
          treeCtx.fill();
        }

        treeCtx.fillStyle = c.core;
        treeCtx.beginPath(); treeCtx.arc(x,y,r*0.35,0,Math.PI*2); treeCtx.fill();

        treeCtx.restore();
      }

      function drawBranchLayer(depth){
        treeCtx.save();
        treeCtx.lineCap = "round";
        treeCtx.strokeStyle = `rgba(66,33,17,${0.35 + depth*0.55})`;

        function branch(x,y, len, ang, d){
          const x2 = x + Math.cos(ang)*len;
          const y2 = y + Math.sin(ang)*len;

          treeCtx.lineWidth = clamp(6.2 - d*1.2, 1.2, 6.2) * (0.85 + depth*0.35);
          treeCtx.beginPath(); treeCtx.moveTo(x,y); treeCtx.lineTo(x2,y2); treeCtx.stroke();

          const blossomCount = Math.max(4, Math.floor(len/16));
          for (let i=0;i<blossomCount;i++){
            const t = (i + rand(0.15,0.85)) / blossomCount;
            const bx = x + (x2-x)*t + rand(-10,10);
            const by = y + (y2-y)*t + rand(-10,10);
            const rr = rand(4.6, 8.6) * (0.75 + depth*0.55);
            drawBlossom(bx, by, rr, depth);
          }

          if (d <= 0) return;
          const n = randi(2,3);
          for (let i=0;i<n;i++){
            branch(x2, y2, len * rand(0.58, 0.76), ang + rand(-0.75,0.75), d - 1);
          }
        }

        const topX = cx;
        const topY = baseY - trunkH;
        const baseLen = Math.min(W*0.22, 190) * (0.78 + depth*0.35);
        const starts = [
          {dx: -12, dy: 16, a: -Math.PI/2 - 0.65},
          {dx:  10, dy: 10, a: -Math.PI/2 - 0.25},
          {dx:   0, dy:  6, a: -Math.PI/2 + 0.10},
          {dx: -6,  dy: 18, a: -Math.PI/2 + 0.45},
          {dx:  12, dy: 22, a: -Math.PI/2 + 0.85},
        ];
        for (const s of starts){
          branch(topX + s.dx*(0.7+depth), topY + s.dy*(0.7+depth), baseLen*rand(0.72,1.0), s.a + rand(-0.08,0.08), 4);
        }

        const puffCount = 22;
        for (let i=0;i<puffCount;i++){
          const px = cx + rand(-W*0.18, W*0.18) + (depth-0.5)*22;
          const py = canopyCenterY + rand(-H*0.12, H*0.10) - (1-depth)*12;
          const pr = rand(18, 40) * (0.7 + depth*0.45);
          const c = blossomColor(depth);
          const puff = treeCtx.createRadialGradient(px,py,1,px,py,pr);
          puff.addColorStop(0, `rgba(255,255,255,${0.02 + depth*0.03})`);
          puff.addColorStop(0.35, c.glow);
          puff.addColorStop(1, "rgba(0,0,0,0)");
          treeCtx.fillStyle = puff;
          treeCtx.beginPath(); treeCtx.arc(px,py,pr,0,Math.PI*2); treeCtx.fill();
        }

        treeCtx.restore();
      }

      drawBranchLayer(0.15);
      drawBranchLayer(0.55);
      drawBranchLayer(0.95);

      // pot
      treeCtx.save();
      const potW = Math.min(280, W*0.36);
      const potH = Math.min(96, H*0.12);
      const potY = baseY + 38;

      treeCtx.fillStyle = "rgba(0,0,0,0.35)";
      treeCtx.beginPath();
      treeCtx.ellipse(cx, potY + potH*0.55, potW*0.48, 18, 0, 0, Math.PI*2);
      treeCtx.fill();

      const potGrad = treeCtx.createLinearGradient(cx - potW/2, potY - potH/2, cx + potW/2, potY + potH/2);
      potGrad.addColorStop(0, "rgba(217,35,46,0.96)");
      potGrad.addColorStop(1, "rgba(179,20,29,0.96)");
      treeCtx.fillStyle = potGrad;

      treeCtx.beginPath();
      treeCtx.roundRect(cx - potW/2, potY - potH/2, potW, potH, 18);
      treeCtx.fill();

      treeCtx.fillStyle = "rgba(255,214,107,0.86)";
      treeCtx.beginPath();
      treeCtx.roundRect(cx - potW*0.55, potY - potH*0.62, potW*1.1, potH*0.22, 16);
      treeCtx.fill();

      treeCtx.fillStyle = "rgba(255,243,214,0.92)";
      treeCtx.font = `900 ${Math.max(18, Math.floor(potH*0.36))}px system-ui`;
      treeCtx.textAlign = "center";
      treeCtx.textBaseline = "middle";
      treeCtx.fillText(treeMode === 'dao' ? "T·∫æT" : "XU√ÇN", cx, potY + potH*0.06);

      treeCtx.restore();
    }

    // =========================
    // Collision avoidance (gentle separation)
    // =========================
    function applyRepulsion(dt){
      // Keep it cheap: few iterations
      const iters = 2;
      const n = lanterns.length;

      // bounds (keep away from edges a bit)
      const margin = Math.max(24, Math.round(22 * getUIScale()));
      const minX = margin, maxX = W - margin;
      const minY = margin + 24, maxY = H - margin; // leave top HUD space a bit

      for (let k=0; k<iters; k++){
        for (let i=0; i<n; i++){
          const a = lanterns[i];

          // boundary soft push
          // boundary soft push
if (a.x < minX){ a.x = minX; a.vx =  Math.abs(a.vx) * 0.7; }
if (a.x > maxX){ a.x = maxX; a.vx = -Math.abs(a.vx) * 0.7; }

// no top clamp (allow flying out)
if (a.y > maxY){ a.y = maxY; a.vy = -Math.abs(a.vy) * 0.7; }


          for (let j=i+1; j<n; j++){
            const b = lanterns[j];
            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const dist = hypot(dx,dy) || 0.0001;

            const minDist = a.clusterR + b.clusterR + 10; // + padding so they don't "kiss"
            if (dist < minDist){
              const overlap = (minDist - dist);

              // normalize
              const nx = dx / dist;
              const ny = dy / dist;

              // separate positions (small)
              const push = overlap * 0.42; // tune: smaller = softer
              a.x -= nx * push;
              a.y -= ny * push;
              b.x += nx * push;
              b.y += ny * push;

              // nudge velocities to drift apart
              const vpush = overlap * 0.0008; // dt-independent small
              a.vx -= nx * vpush;
              a.vy -= ny * vpush;
              b.vx += nx * vpush;
              b.vy += ny * vpush;
            }
          }
        }
      }

      // mild damping to prevent jitter
      const damp = Math.pow(0.995, dt); // dt in ms
      for (const o of lanterns){
        o.vx *= damp;
        o.vy *= damp;
      }
    }

    // =========================
    // Hit test
    // =========================
    function hitEnvelope(mx, my){
      // check closer ones first (by y)
      const sorted = [...lanterns].sort((a,b)=> (b.hit?.y ?? 0) - (a.hit?.y ?? 0));
      for (const o of sorted){
        if (!o.hit) continue;
        const {x,y,w,h} = o.hit;
        if (mx >= x && mx <= x+w && my >= y && my <= y+h) return o;
      }
      return null;
    }

    addEventListener('pointerdown', (e)=>{
      if (overlay.style.display === "flex") return;
      const o = hitEnvelope(e.clientX, e.clientY);
      if (o) openPopup(o.value);
    });

    // =========================
    // Controls
    // =========================
    document.getElementById('regenBtn').addEventListener('click', ()=>{
      populate();
    });
    document.getElementById('switchBtn').addEventListener('click', ()=>{
      treeMode = (treeMode === 'dao') ? 'mai' : 'dao';
      setModeBadge();
      renderTreeLayer(); // redraw static tree once
    });

    // =========================
    // Resize
    // =========================
    function resize(){
      DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      W = Math.floor(innerWidth);
      H = Math.floor(innerHeight);

      canvas.width = Math.floor(W * DPR);
      canvas.height = Math.floor(H * DPR);
      canvas.style.width = W + "px";
      canvas.style.height = H + "px";
      ctx.setTransform(DPR,0,0,DPR,0,0);

      treeCanvas.width = Math.floor(W * DPR);
      treeCanvas.height = Math.floor(H * DPR);
      treeCtx.setTransform(DPR,0,0,DPR,0,0);

      renderTreeLayer();
      populate();
    }
    addEventListener('resize', resize);

    // =========================
    // Animation loop (lanterns only)
    // =========================
    let last = performance.now();
    function frame(now){
      const dt = Math.min(32, now - last); // ms
      last = now;

      ctx.clearRect(0,0,W,H);
      drawBackground();

      // draw static tree (cheap)
      ctx.drawImage(treeCanvas, 0, 0, W, H);

      // integrate motion
      for (const o of lanterns){
        o.sway += o.swaySpd * dt;
        o.x += o.vx * dt;
        o.y += o.vy * dt;
        // respawn khi ra kh·ªèi m√†n h√¨nh ph√≠a tr√™n
const buffer = 120 * getUIScale();
if (o.y < -buffer){
  o.y = H + rand(60, 220);
  o.x = rand(W * 0.10, W * 0.90);

  // reset sway nh·∫π ƒë·ªÉ nh√¨n t·ª± nhi√™n
  o.sway = rand(0, Math.PI * 2);

  // gi·ªØ bay l√™n
  o.vy = -rand(0.020, 0.045) * getUIScale();
  o.vx = rand(-0.012, 0.012) * getUIScale();
}

        // wrap is removed to avoid sudden jumps; we use bounds+repulsion instead
      }

      // repel to avoid overlap during motion
      applyRepulsion(dt);

      // draw lanterns
      for (const o of lanterns){
        drawLanternWithEnvelope(o);
      }

      // title
      ctx.save();
      ctx.globalAlpha = 0.92;
      ctx.fillStyle = "rgba(255,243,214,0.92)";
      ctx.font = `900 ${Math.max(16, Math.floor(Math.min(W,H)*0.032))}px system-ui`;
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.shadowColor = "rgba(0,0,0,0.35)";
      ctx.shadowBlur = 10;
      ctx.fillText("Ch√∫c M·ª´ng NƒÉm M·ªõi", W*0.5, 14);
      ctx.restore();

      requestAnimationFrame(frame);
    }

    // =========================
    // Init
    // =========================
    resize();
    requestAnimationFrame(frame);
  </script>
</body>
</html>
